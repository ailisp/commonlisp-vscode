<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>comment</key>
	<string>Bastien Dejean, june 2010</string>
	<key>fileTypes</key>
	<array>
		<string>lisp</string>
		<string>lsp</string>
		<string>asd</string>
		<string>asdf</string>
		<string>cl</string>
		<string>ros</string>
	</array>
	<key>firstLineMatch</key>
	<string>^(?i:;+\s*-\*-\s*(mode:)?\s*lisp.*-\*-.*)$</string>
	<key>foldingStartMarker</key>
	<string>^\(</string>
	<key>foldingStopMarker</key>
	<string>^\s*$</string>
	<key>keyEquivalent</key>
	<string>^~L</string>
	<key>name</key>
	<string>Common Lisp</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>include</key>
			<string>#atom</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#list</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#comment</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>atom</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#number</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#symbol</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#misc</string>
				</dict>
			</array>
		</dict>
		<key>comment</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>#\|</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.block-comment.begin.lisp</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\|#</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.block-comment.end.lisp</string>
						</dict>
					</dict>
					<key>name</key>
					<string>comment.block.lisp</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#link</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>match</key>
					<string>;.*$</string>
					<key>name</key>
					<string>comment.line.lisp</string>
				</dict>
			</array>
		</dict>
		<key>link</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?x)
						( (https?|s?ftp|ftps|file|smb|afp|nfs|(x-)?man|gopher|txmt)://|mailto:)
						[-:@a-zA-Z0-9_.,~%+/?=&amp;#]+(?&lt;![.,?:])
					</string>
					<key>name</key>
					<string>markup.underline.link.lisp</string>
				</dict>
			</array>
		</dict>
		<key>list</key>
		<dict>
			<key>begin</key>
			<string>\(</string>
			<key>beginCaptures</key>
			<dict>
				<key>0</key>
				<dict>
					<key>name</key>
					<string>punctuation.definition.list.begin.lisp</string>
				</dict>
			</dict>
			<key>end</key>
			<string>\)</string>
			<key>endCaptures</key>
			<dict>
				<key>0</key>
				<dict>
					<key>name</key>
					<string>punctuation.definition.list.end.lisp</string>
				</dict>
			</dict>
			<key>name</key>
			<string>meta.list.lisp</string>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>$self</string>
				</dict>
			</array>
		</dict>
		<key>misc</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>"</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.lisp</string>
						</dict>
					</dict>
					<key>end</key>
					<string>"</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.lisp</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.lisp</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>\\.</string>
							<key>name</key>
							<string>constant.character.escape.lisp</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(?i:~(([+-]?\d+|'.|[v#])?,?)*(:?@?|@?:?)[crdboxefgptiasw%&amp;(){}\[\]$*?|^&lt;_&gt;/;~])</string>
							<key>name</key>
							<string>constant.character.format-directive.lisp</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#link</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\|</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.symbol.begin.lisp</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\|</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.symbol.end.lisp</string>
						</dict>
					</dict>
					<key>name</key>
					<string>constant.other.symbol.lisp</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#link</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>match</key>
					<string>(?&lt;=[()\s]|^)\#\\([A-Za-z_\-]+|.(?=[()\s]))</string>
					<key>name</key>
					<string>constant.character.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
    				                (?&lt;=[()\s]|^)
    				                \#\d*\*
    				                [01]*
    				                (?=[()\s]|$)
    				         )</string>
					<key>name</key>
					<string>constant.other.bit-vector.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
	                            (?&lt;=[()\s]|^)
        				        ( :[^()\s]+ )        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.keyword.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
	                            (?&lt;=[()\s]|^)
        				        ( [^()\s]+:{1,2}[^()\s]+ )        				        
        				     )</string>
					<key>name</key>
					<string>variable.other.external-symbol.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
	                            (?&lt;=[()\s]|^)
        				        ( \#p )        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.pathname.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
	                            (?&lt;=[()\s]|^)
        				        ( \#' )        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.function.abbreviation.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
	                            (?&lt;=[()\s]|^)
        				        ( \#[+-] )        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.read-time.conditional.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
	                            (?&lt;=[()\s]|^)
        				        ( \#\d+a )        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.array.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
    	                            (?&lt;=[()\s]|^)
            				        ( \#s )
            				        (?=\()        				        
            				     )</string>
					<key>name</key>
					<string>keyword.other.structure.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
	                            (?&lt;=[()\s]|^)
        				        ( \#\d* )
        				        (?=\()        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.vector.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
	                            (?&lt;=[()\s]|^)
        				        ( \#\. )        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.read-time.evaluation.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
	                            (?&lt;=[()\s]|^)
        				        ( \#, )        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.load-time.evaluation.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
                                (?&lt;=[()\s]|^)
                                ( \#: )                             
                             )</string>
					<key>name</key>
					<string>keyword.other.uninterned-symbol.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
                                (?&lt;=[()\s]|^)
                                ( \#[!?{}\[\]] )                             
                             )</string>
					<key>name</key>
					<string>keyword.other.definable.reader-macro.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
	                            (?&lt;=[()\s]|^)
        				        ( \#\d+[=#] )        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.object-definition.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
	                            (?&lt;=[()\s]|^)
        				        ( ['`] | ,[@.]? )        				        
        				     )</string>
					<key>name</key>
					<string>keyword.other.special.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\#&lt;</string>
					<key>name</key>
					<string>invalid.illegal.lisp</string>
				</dict>
			</array>
		</dict>
		<key>number</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?xi:
    				                
    				                (?&lt;=[()\s]|^)
    				                [+-]?
    				                (
    				                    \d+
    				                    ( /
    				                        \d+)? |
    				                    \d+
        				                ( \.
        				                    \d*)?
        				                ( [esfdl]
        				                    [+-]? \d+)?
        				            )
        				            (?=[()\s]|$)
    				         )</string>
					<key>name</key>
					<string>constant.numeric.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
    				                (?&lt;=[()\s]|^)
    				                \#c
    				                \s*
    				                \(
    				                    [^)]*
    				                    \s+
    				                    [^)]*
    				                \)
        				            (?=[()\s]|$)
    				         )</string>
					<key>name</key>
					<string>constant.numeric.complex.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
    				                (?&lt;=[()\s]|^)
    				                \#x
    				                [+-]?
    				                [0-9a-f]+
    				                ( /
    				                    [0-9a-f]+)?
    				                (?=[()\s]|$)
    				         )</string>
					<key>name</key>
					<string>constant.numeric.hexidecimal.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
    				                (?&lt;=[()\s]|^)
    				                \#o
    				                [+-]?
    				                [0-7]+
    				                ( /
    				                    [0-7]+)?
    				                (?=[()\s]|$)
    				                
    				         )</string>
					<key>name</key>
					<string>constant.numeric.octal.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
    				                (?&lt;=[()\s]|^)
    				                \#b
    				                [+-]?
    				                [01]+
    				                ( /
    				                    [01]+)?
    				                (?=[()\s]|$)
    				         )</string>
					<key>name</key>
					<string>constant.numeric.binary.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
                                     (?&lt;=[()\s]|^)
                                     \# \d+ r
                                     [+-]?
                                     [0-9a-z]+
                                     ( /
                                         [0-9a-z]+)?
                                     (?=[()\s]|$)
                               )</string>
					<key>name</key>
					<string>constant.numeric.general-base.lisp</string>
				</dict>
			</array>
		</dict>
		<key>symbol</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?xi:
        				        (?&lt;=[()\s]|^)
        				        ( nil | t )
        				        (?=[()\s]|$)
        				    )</string>
					<key>name</key>
					<string>constant.language.lisp</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.function.lisp</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.name.function.lisp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( defun | defmacro | defmethod )
                                 \s+
                                 ( [^\s()]+ )
                              )</string>
					<key>name</key>
					<string>meta.storage.type.function.lisp</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.variable.lisp</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>variable.other.lisp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( defvar | defconstant | defparameter )
                                 \s+
                                 ( [^\s()]+ )
                              )</string>
					<key>name</key>
					<string>meta.storage.type.variable.lisp</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.class.lisp</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.name.class.lisp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( defclass )
                                 \s+
                                 ( [^\s()]+ )
                              )</string>
					<key>name</key>
					<string>meta.storage.type.class.lisp</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.type.lisp</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.name.type.lisp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( deftype )
                                 \s+
                                 ( [^\s()]+ )
                              )</string>
					<key>name</key>
					<string>meta.storage.type.class.lisp</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.structure.lisp</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.name.structure.lisp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( defstruct )
                                 \s+
                                 ( [^\s()]+ )
                              )</string>
					<key>name</key>
					<string>meta.storage.type.class.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( defstruct )
                                 (?=\s\()                                 
                              )</string>
					<key>name</key>
					<string>storage.type.structure.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(defstruct\s\()
                                 ( [^\s()]+ )
                              )</string>
					<key>name</key>
					<string>entity.name.structure.structure.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( defun )
                                 (?=\s\(setf)                                 
                              )</string>
					<key>name</key>
					<string>storage.type.function.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( \* | \+ | - | / | 1\+ | 1- | do | ed | go | if | or | abs | and | ash | bit | car | cdr | cis | cos | do\* | dpb | elt | exp | gcd | get | lcm | ldb | let | log | map | max | min | mod | not | nth | pop | rem | set | sin | tan | the | acos | aref | asin | atan | byte | caar | cadr | case | cdar | cddr | char | cond | cons | cosh | decf | eval | expt | fill | find | flet | getf | incf | last | let\* | list | load | loop | mapc | mapl | prog | push | real | remf | rest | room | sbit | setf | setq | sinh | some | sort | sqrt | step | tanh | time | type | warn | when | abort | acons | acosh | apply | array | asinh | assoc | atanh | block | boole | break | caaar | caadr | cadar | caddr | catch | ccase | cdaar | cdadr | cddar | cdddr | class | count | debug | ecase | error | every | fifth | first | float | floor | ftype | isqrt | ldiff | list\* | merge | nconc | ninth | phase | prog\* | prog1 | prog2 | progn | progv | psetf | psetq | quote | ratio | round | schar | sixth | sleep | space | speed | subst | svref | tenth | third | throw | trace | union | adjoin | append | assert | bignum | caaaar | caaadr | caadar | caaddr | cadaar | cadadr | caddar | cadddr | cdaaar | cdaadr | cdadar | cdaddr | cddaar | cddadr | cdddar | cddddr | cerror | coerce | delete | dolist | eighth | export | ffloor | fixnum | fourth | fround | gensym | ignore | import | inline | intern | labels | lambda | length | logand | logeqv | logior | lognor | lognot | logxor | mapcan | mapcar | mapcon | member | method | notany | nsubst | nthcdr | number | nunion | random | rassoc | reduce | remove | return | rplaca | rplacd | safety | search | second | shadow | shiftf | signal | signum | string | sublis | subseq | sxhash | symbol | unless | values | vector | apropos | bit-and | bit-eqv | bit-ior | bit-nor | bit-not | bit-xor | boolean | butlast | ceiling | clrhash | compile | complex | declaim | declare | defsetf | dotimes | dribble | find-if | funcall | gentemp | gethash | inspect | integer | keyword | locally | lognand | logorc1 | logorc2 | logtest | maphash | maplist | nreconc | nsublis | package | pairlis | provide | pushnew | remhash | remprop | replace | require | restart | reverse | rotatef | seventh | special | tagbody | type-of | untrace | warning | assoc-if | bit-nand | bit-orc1 | bit-orc2 | char-int | class-of | continue | copy-seq | count-if | describe | fceiling | function | identity | imagpart | ldb-test | logandc1 | logandc2 | logcount | macrolet | map-into | mismatch | nbutlast | notevery | nreverse | optimize | position | proclaim | rational | realpart | sequence | standard | subst-if | truename | truncate | typecase | unexport | unintern | variable | base-char | bit-andc1 | bit-andc2 | byte-size | char-code | char-name | character | code-char | condition | conjugate | copy-list | copy-tree | ctypecase | delete-if | etypecase | eval-when | ftruncate | ignorable | make-list | member-if | name-char | notinline | nsubst-if | nth-value | numerator | otherwise | rassoc-if | remove-if | revappend | satisfies | structure | use-value | add-method | array-rank | bit-vector | cell-error | check-type | class-name | complement | constantly | copy-alist | defgeneric | defpackage | digit-char | do-symbols | find-class | float-sign | hash-table | in-package | long-float | make-array | makunbound | mask-field | namestring | slot-value | substitute | type-error | vector-pop | with-slots | base-string | call-method | char-upcase | concatenate | copy-symbol | declaration | denominator | disassemble | fdefinition | find-if-not | find-method | find-symbol | float-radix | fmakunbound | list-length | loop-finish | macroexpand | make-method | make-string | make-symbol | nsubstitute | parse-error | position-if | rationalize | return-from | scale-float | short-float | signed-byte | stable-sort | store-value | string-trim | symbol-name | use-package | values-list | vector-push | adjust-array | apropos-list | assoc-if-not | change-class | compile-file | count-if-not | decode-float | double-float | fill-pointer | find-package | find-restart | float-digits | handler-bind | handler-case | intersection | machine-type | make-package | package-name | random-state | restart-bind | restart-case | restart-name | simple-array | simple-error | single-float | slot-missing | slot-unbound | subst-if-not | symbol-plist | symbol-value | unbound-slot | byte-position | char-downcase | control-error | delete-if-not | deposit-field | documentation | extended-char | ignore-errors | macroexpand-1 | make-instance | make-sequence | member-if-not | nintersection | nsubst-if-not | package-error | parse-integer | program-error | rassoc-if-not | remove-if-not | remove-method | simple-string | simple-vector | software-type | standard-char | string-upcase | style-warning | substitute-if | unsigned-byte | unuse-package | built-in-class | compiler-macro | copy-structure | delete-package | do-all-symbols | dynamic-extent | get-properties | integer-length | invoke-restart | long-site-name | macro-function | make-condition | make-load-form | muffle-warning | no-next-method | nstring-upcase | nsubstitute-if | rename-package | row-major-aref | set-difference | simple-warning | standard-class | symbol-package | unwind-protect | with-accessors | array-dimension | cell-error-name | describe-object | float-precision | hash-table-size | hash-table-test | host-namestring | invoke-debugger | load-time-value | machine-version | make-hash-table | nset-difference | position-if-not | short-site-name | slot-makunbound | standard-method | standard-object | string-downcase | structure-class | symbol-function | symbol-macrolet | arithmetic-error | array-dimensions | array-total-size | call-next-method | compute-restarts | define-condition | division-by-zero | find-all-symbols | generic-function | get-decoded-time | hash-table-count | machine-instance | nstring-downcase | package-use-list | parse-namestring | set-exclusive-or | shadowing-import | simple-condition | software-version | string-left-trim | structure-object | type-error-datum | unbound-variable | allocate-instance | compilation-speed | compiled-function | delete-duplicates | enough-namestring | function-keywords | list-all-packages | make-random-state | method-qualifiers | nset-exclusive-or | package-nicknames | remove-duplicates | serious-condition | shared-initialize | simple-bit-vector | simple-type-error | storage-condition | string-capitalize | string-right-trim | substitute-if-not | array-displacement | array-element-type | destructuring-bind | get-setf-expansion | get-universal-time | method-combination | nstring-capitalize | nsubstitute-if-not | simple-base-string | undefined-function | vector-push-extend | define-modify-macro | define-symbol-macro | do-external-symbols | get-macro-character | initialize-instance | multiple-value-bind | multiple-value-call | multiple-value-list | multiple-value-setq | set-macro-character | with-simple-restart | define-setf-expander | integer-decode-float | invalid-method-error | multiple-value-prog1 | no-applicable-method | package-used-by-list | set-syntax-from-char | array-row-major-index | compile-file-pathname | decode-universal-time | define-compiler-macro | encode-universal-time | get-internal-run-time | package-error-package | reinitialize-instance | unbound-slot-instance | with-compilation-unit | with-package-iterator | floating-point-inexact | get-internal-real-time | hash-table-rehash-size | compiler-macro-function | ensure-generic-function | floating-point-overflow | make-instances-obsolete | with-condition-restarts | floating-point-underflow | lisp-implementation-type | method-combination-error | type-error-expected-type | with-hash-table-iterator | arithmetic-error-operands | define-method-combination | package-shadowing-symbols | standard-generic-function | arithmetic-error-operation | compute-applicable-methods | function-lambda-expression | upgraded-complex-part-type | hash-table-rehash-threshold | lisp-implementation-version | make-load-form-saving-slots | upgraded-array-element-type | get-dispatch-macro-character | invoke-restart-interactively | set-dispatch-macro-character | make-dispatch-macro-character | simple-condition-format-control | floating-point-invalid-operation | simple-condition-format-arguments | update-instance-for-different-class | update-instance-for-redefined-class )
                                 (?=[()\s])
                              )</string>
					<key>name</key>
					<string>entity.name.function.misc.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( load | open | read | close | prin1 | princ | print | write | format | listen | pprint | stream | terpri | require | pathname | truename | directory | formatter | peek-char | read-byte | read-char | read-line | readtable | file-error | fresh-line | namestring | pprint-pop | pprint-tab | probe-file | write-byte | write-char | write-line | clear-input | delete-file | echo-stream | end-of-file | file-author | file-length | file-stream | pprint-fill | rename-file | unread-char | clear-output | compile-file | force-output | print-object | reader-error | stream-error | write-string | file-position | finish-output | make-pathname | pathname-host | pathname-name | pathname-type | pprint-indent | pprint-linear | read-sequence | string-stream | copy-readtable | pprint-newline | pprint-tabular | readtable-case | synonym-stream | two-way-stream | with-open-file | write-sequence | file-namestring | file-write-date | host-namestring | merge-pathnames | pathname-device | pprint-dispatch | prin1-to-string | princ-to-string | write-to-string | broadcast-stream | logical-pathname | make-echo-stream | parse-namestring | pathname-version | read-from-string | with-open-stream | enough-namestring | read-char-no-hang | file-string-length | pathname-directory | print-not-readable | translate-pathname | concatenated-stream | file-error-pathname | make-synonym-stream | make-two-way-stream | read-delimited-list | set-pprint-dispatch | stream-element-type | stream-error-stream | copy-pprint-dispatch | directory-namestring | pprint-logical-block | compile-file-pathname | make-broadcast-stream | synonym-stream-symbol | user-homedir-pathname | with-output-to-string | stream-external-format | with-input-from-string | print-unreadable-object | with-standard-io-syntax | broadcast-stream-streams | echo-stream-input-stream | ensure-directories-exist | get-output-stream-string | make-concatenated-stream | make-string-input-stream | echo-stream-output-stream | make-string-output-stream | print-not-readable-object | read-preserving-whitespace | translate-logical-pathname | concatenated-stream-streams | two-way-stream-input-stream | two-way-stream-output-stream | logical-pathname-translations | pprint-exit-if-list-exhausted | load-logical-pathname-translations )
                                 (?=[()\s])
                              )</string>
					<key>name</key>
					<string>entity.name.function.io.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
                                 (?&lt;=\(|\#')
                                 ( &lt; | = | &gt; | /= | &lt;= | &gt;= | eq | eql | atom | endp | null | oddp | char&lt; | char= | char&gt; | consp | equal | evenp | listp | plusp | realp | tailp | typep | zerop | arrayp | boundp | char/= | char&lt;= | char&gt;= | equalp | floatp | minusp | fboundp | logbitp | numberp | streamp | string&lt; | string= | string&gt; | stringp | subsetp | symbolp | vectorp | complexp | integerp | keywordp | packagep | string/= | string&lt;= | string&gt;= | subtypep | y-or-n-p | constantp | functionp | pathnamep | rationalp | char-equal | char-lessp | characterp | readtablep | tree-equal | both-case-p | slot-boundp | yes-or-no-p | alpha-char-p | bit-vector-p | digit-char-p | hash-table-p | lower-case-p | string-equal | string-lessp | upper-case-p | alphanumericp | char-greaterp | next-method-p | open-stream-p | slot-exists-p | char-not-equal | char-not-lessp | graphic-char-p | input-stream-p | random-state-p | output-stream-p | simple-string-p | simple-vector-p | standard-char-p | string-greaterp | wild-pathname-p | pathname-match-p | string-not-equal | string-not-lessp | array-in-bounds-p | char-not-greaterp | adjustable-array-p | special-operator-p | compiled-function-p | simple-bit-vector-p | string-not-greaterp | interactive-stream-p | array-has-fill-pointer-p )
                                 (?=[()\s])
                              )</string>
					<key>name</key>
					<string>entity.name.function.predicate.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
        				        (?&lt;=[()\s]|^)
        				        &amp; ( optional | rest | key | whole | body | aux | environment | allow-other-keys )
        				        (?=[()\s]|$)
        				     )</string>
					<key>name</key>
					<string>storage.modifier.function.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?x:
                                (?&lt;=[()\s]|^)
				                ([*+%])
                                [^\s()]*
                                \1
                                (?=[()\s]|$)
                            )</string>
					<key>name</key>
					<string>variable.other.special.lisp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?xi:
        				        (?&lt;=[()\s]|^)
        				        ( pi | boole-1 | boole-2 | boole-c1 | boole-c2 | boole-and | boole-clr | boole-eqv | boole-ior | boole-nor | boole-set | boole-xor | boole-nand | boole-orc1 | boole-orc2 | boole-andc1 | boole-andc2 | char-code-limit | array-rank-limit | long-float-epsilon | short-float-epsilon | call-arguments-limit | double-float-epsilon | lambda-list-keywords | most-negative-fixnum | most-positive-fixnum | single-float-epsilon | array-dimension-limit | multiple-values-limit | array-total-size-limit | lambda-parameters-limit | most-negative-long-float | most-positive-long-float | least-negative-long-float | least-positive-long-float | most-negative-short-float | most-positive-short-float | least-negative-short-float | least-positive-short-float | most-negative-double-float | most-negative-single-float | most-positive-double-float | most-positive-single-float | least-negative-double-float | least-negative-single-float | least-positive-double-float | least-positive-single-float | long-float-negative-epsilon | short-float-negative-epsilon | double-float-negative-epsilon | single-float-negative-epsilon | internal-time-units-per-second | least-negative-normalized-long-float | least-positive-normalized-long-float | least-negative-normalized-short-float | least-positive-normalized-short-float | least-negative-normalized-double-float | least-negative-normalized-single-float | least-positive-normalized-double-float | least-positive-normalized-single-float )
        				        (?=[()\s]|$)
        				    )</string>
					<key>name</key>
					<string>constant.language.other.lisp</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.commonlisp</string>
	<key>uuid</key>
	<string>CECF0080-7B0C-46DD-BAC6-AE2FA80F81EC</string>
</dict>
</plist>
